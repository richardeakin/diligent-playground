
#define PHYSICS_SIM 0
#include "shaders/canvas/sdfScene.fxh"

// TODO: try removing the paddings, but make sure it is %16 still
struct BackgroundPixelConstants {
    float4x4 viewProj;
    float4x4 inverseViewProj;

    float3 camPos;
    float  padding0;

    float3 camDir;
    float  padding1;

    float3 lightDir;
    float padding2;

    float3 fogColor;
    float padding3;

    float2 resolution;
    float  padding4;
    float  padding5;

    float3  worldMin;
    float   padding6;

    float3  worldMax;
    float   padding7;
};

cbuffer Constants {
    BackgroundPixelConstants Constants;
};


struct PSInput {
    float4 Pos   : SV_POSITION;
    float2 UV    : TEX_COORD;
};

struct PSOutput {
    float4 Color : SV_TARGET;
    float  Depth : SV_Depth;
};


float3 skyColor( in Ray ray )
{
    float3 col = float3( 0.1, 0.05, 0.1 ) * 0.1;
    float ss1 = smoothstep( 0.0, 4.0, max( ray.dir.y + 0.1, 0.0 ) * 5.0 );
    col = lerp( col, float3( 0.7, 0.17, 0.03 ), ss1 );
    //col += ray.dir.y * 0.15;

    float ss2 = smoothstep( 0.0, 5.0, pow( max( ray.dir.y, 0.0 ), 1.3 ) * 10.0 );
    col = lerp( col, float3( 0.02, 0.03, 0.5 ), ss2 );

    // TODO NEXT: mix with mPostProcessConstants at y = 0
    float horizon = smoothstep( 0, 0.2, ray.dir.y );
    col = lerp( Constants.fogColor, col, horizon );

    return col;
}

void main( in PSInput PSIn, out PSOutput PSOut )
{
    float2 pixelCoord = PSIn.Pos.xy;

    float2 uv = PSIn.UV;
    uv.y = 1.0 - uv.y;
    float4 worldPos = mul( float4( uv * 2.0 - 1.0, 1.0, 1.0 ), Constants.inverseViewProj );

    Ray ray;
    ray.origin = Constants.camPos;
    ray.dir    = normalize( worldPos.xyz / worldPos.w - Constants.camPos );

    float3 col = float3( 0, 0, 0 );
    float emission = 0.0;
    ObjectInfo object = initObjectInfo(); 
    IntersectInfo intersect = INTERSECT_FN( ray, object, Constants.worldMin, Constants.worldMax );
    if( object.id != oid_nothing ) {
        //col = sdf_shadeScene( ray, object, intersect );

        float3 skyColor = float3( 0.25, 0.1, 0.4 ); // should match background horizon, may want to sample it
        float3 lightDir = normalize( -Constants.lightDir ); 
        float light_diff = saturate( dot( object.normal, lightDir ) );
        float sky_diff = saturate( dot( object.normal, float3( 0, 1, 0 ) ) );

        // checker floor pattern
        float2 xz = object.pos.xz;
        float2 x_ddx = ddx( xz ); 
        float2 x_ddy = ddy( xz ); 
        float checker = checkersGrad( xz, x_ddx, x_ddy );
        float3 checkerCol = 0.1 + checker * float3( 0.3, 0.3, 0.3 );
        //checkerCol = float3( 0, 0, 1 );
        //if( object.id == oid_floor ) {
            col = checkerCol;
            //col = float3( 0, 0, 1 ); // TODO NEXT: make this blend smoothly with red sphere as in iq article
        //}
        //if( object.id == oid_ball ) {
            //col = float3( 0.1, 0, 0 );

            //float3 baseColor = float3( 1.0, 0.5, 0.1 ); // purple
            float3 baseColor = float3( 0.0, 0.5, 0.1 ); // green

            float3 ballCol = baseColor * light_diff;
            ballCol += skyColor * sky_diff * 0.5;

            col = lerp( checkerCol, ballCol, object.materialPart );
            //col = checkerCol;

            //col = float3( object.materialPart, 0, 0 );
            //if( object.materialPart > 0.7 ) {
            //    col = float3( 1, 0, 0 );
            //}

            //emission = 0.5; // TODO: write this from material fn, vary based on which object and time
        //}

        if( object.id == oid_bbox ) {

            col = float3( 0.5, 0.5, 0.5 );
        }

        if( object.id == oid_cone ) {

            col = float3( 0.0, 0.5, 0.0 );
        }

        col = object.normal;
        
        // set pixel depth in normalized [0, 1] range
        float4 clipPos = mul( float4( object.pos, 1.0 ), Constants.viewProj );
        PSOut.Depth = clipPos.z / clipPos.w;

#if DEBUG_SDF_GRADIENT
    float nl = length( object.normal );
    if( nl <= 0 ) {
        col = float3( 1, 0, 0 );
    }
    else if( nl < 0.1 ) {
        col.g = smoothstep( 0.0, 0.1, nl );
    }
#endif

    }
    else {
        col = skyColor( ray );
        PSOut.Depth = 0.9999;
    }

    //if( p.y > 0.0 ) {
    //    col = float3( 0, 1, 0 );
    //}

    //col = col * 0.001 + float3( uv.x, uv.y, 0 );

    PSOut.Color = float4( col, emission );
}
